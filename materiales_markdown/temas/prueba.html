<h1
id="m√≥dulo-1-fundamentos-de-estructuras-de-datos-y-an√°lisis-de-algoritmos">M√≥dulo
1 ‚Äì Fundamentos de estructuras de datos y an√°lisis de algoritmos</h1>
<hr />
<h2 id="objetivos-del-m√≥dulo">Objetivos del m√≥dulo</h2>
<p>Al finalizar este m√≥dulo el estudiante ser√° capaz de:</p>
<ul>
<li>Definir qu√© es un algoritmo y describir sus propiedades
esenciales.<br />
</li>
<li>Analizar la eficiencia de un algoritmo en tiempo y memoria
utilizando notaci√≥n Big O.<br />
</li>
<li>Reconocer diferentes paradigmas algor√≠tmicos (divide y vencer√°s,
voraces, programaci√≥n din√°mica).<br />
</li>
<li>Explicar qu√© es un tipo de dato abstracto (TDA) y por qu√© es
independiente de su implementaci√≥n.<br />
</li>
<li>Comprender el funcionamiento de vectores y matrices como estructuras
de datos est√°ticas.</li>
</ul>
<hr />
<h2 id="introducci√≥n">1. Introducci√≥n</h2>
<p>Cuando hablamos de <strong>algoritmos</strong>, nos referimos a algo
tan cotidiano como universal. Un algoritmo no es exclusivo de la
inform√°tica: es cualquier secuencia <strong>finita y ordenada</strong>
de pasos que, si se ejecutan correctamente, conducen a la soluci√≥n de un
problema.</p>
<ul>
<li>La receta de una tortilla de patatas es un algoritmo: lista de
ingredientes (entrada), pasos de preparaci√≥n (proceso) y el plato final
(salida).</li>
<li>Seguir las instrucciones para montar un mueble de IKEA es otro
algoritmo: si no cumples un paso o lo interpretas mal, el resultado no
ser√° el esperado.</li>
<li>Incluso actividades b√°sicas como calcular mentalmente el cambio al
pagar en efectivo son algoritmos en acci√≥n.</li>
</ul>
<p>Lo que distingue a los algoritmos en <strong>ciencias de la
computaci√≥n</strong> es que deben estar formulados de forma tan precisa
y sin ambig√ºedades que <strong>una m√°quina pueda ejecutarlos</strong>.
El ordenador no tiene intuici√≥n ni interpreta el contexto como lo har√≠a
un humano: si las instrucciones son vagas o incompletas, simplemente no
sabr√° qu√© hacer.</p>
<hr />
<h3 id="la-importancia-de-la-eficiencia">1.1 La importancia de la
eficiencia</h3>
<p>Resolver un problema es el primer paso, pero resolverlo de manera
<strong>eficiente</strong> es lo que hace que un algoritmo sea √∫til en
la pr√°ctica.</p>
<p>Un ejemplo cotidiano:</p>
<ul>
<li>Imagina que tienes un diccionario con 100.000 palabras y buscas una
en concreto. Puedes leer palabra por palabra desde el inicio
(<strong>algoritmo lineal, O(n)</strong>), o usar el √≠ndice alfab√©tico
para descartar mitades sucesivas (<strong>b√∫squeda binaria, O(log
n)</strong>). Ambas opciones encuentran la respuesta, pero la segunda lo
hace en mil√©simas de segundo, incluso para vol√∫menes de datos
enormes.</li>
</ul>
<p>En inform√°tica moderna, esta diferencia puede ser la frontera entre
lo <strong>viable</strong> y lo <strong>imposible</strong>:</p>
<ul>
<li>Google no podr√≠a responder a miles de millones de b√∫squedas diarias
sin algoritmos de b√∫squeda altamente optimizados.</li>
<li>La secuenciaci√≥n del genoma humano no habr√≠a sido factible en plazos
razonables si no se hubieran desarrollado algoritmos y estructuras de
datos especializados para manejar grandes vol√∫menes de informaci√≥n.</li>
<li>Aplicaciones como Netflix o Spotify, que recomiendan contenidos en
tiempo real, dependen de algoritmos capaces de procesar datos en
fracciones de segundo.</li>
</ul>
<hr />
<h3 id="estructuras-de-datos-el-soporte-de-los-algoritmos">1.2
Estructuras de datos: el soporte de los algoritmos</h3>
<p>Los algoritmos no trabajan en el vac√≠o: necesitan
<strong>datos</strong> sobre los que operar. Aqu√≠ entran en juego las
<strong>estructuras de datos</strong>, que son formas organizadas de
almacenar y gestionar la informaci√≥n.</p>
<p>Un mismo conjunto de datos puede volverse f√°cil o dif√≠cil de manejar
seg√∫n c√≥mo se organice:</p>
<ul>
<li>Si guardas los contactos de tu m√≥vil en una simple lista
desordenada, encontrar a alguien concreto requerir√° recorrer todos los
nombres uno por uno.</li>
<li>En cambio, si los organizas en un √°rbol balanceado o en una tabla
hash, la b√∫squeda se convierte en una operaci√≥n casi instant√°nea.</li>
</ul>
<p>Dicho de otro modo: <strong>los algoritmos son los procesos, y las
estructuras de datos son el soporte donde esos procesos se ejecutan de
manera eficiente</strong>.</p>
<hr />
<h3 id="conceptos-clave-de-este-m√≥dulo">1.3 Conceptos clave de este
m√≥dulo</h3>
<p>En este m√≥dulo introduciremos las <strong>piedras angulares</strong>
sobre las que se construye todo el estudio de algoritmos y estructuras
de datos:</p>
<ul>
<li><strong>Tipos de Dato Abstracto (TDA)</strong>: nos permiten definir
qu√© operaciones podemos hacer con una estructura (ej. apilar, desapilar
en una pila) sin preocuparnos a√∫n de c√≥mo se implementan. Esto favorece
la <strong>abstracci√≥n</strong> y el dise√±o modular.</li>
<li><strong>Notaci√≥n Big O</strong>: la herramienta matem√°tica que
usamos para expresar la eficiencia de los algoritmos, especialmente
cuando el tama√±o de los datos crece. No nos interesa solo saber ‚Äúcu√°nto
tarda‚Äù un programa en un caso concreto, sino prever c√≥mo escalar√° con
miles o millones de datos.</li>
<li><strong>Paradigmas algor√≠tmicos</strong>: las ‚Äúfamilias‚Äù de
estrategias que permiten resolver problemas de forma general (divide y
vencer√°s, algoritmos voraces, programaci√≥n din√°mica). Cada paradigma
tiene fortalezas y limitaciones que conviene conocer para elegir el
enfoque adecuado.</li>
<li><strong>Vectores (arrays)</strong>: la primera estructura de datos
que estudiaremos. Aunque sencilla, es fundamental para entender la
relaci√≥n entre organizaci√≥n de la memoria, acceso r√°pido a elementos y
coste de operaciones m√°s complejas como inserciones o borrados.</li>
</ul>
<hr />
<h3 id="mirando-hacia-adelante">1.4 Mirando hacia adelante</h3>
<p>Dominar estos fundamentos no es un fin en s√≠ mismo, sino un
<strong>punto de partida</strong>. Al finalizar el m√≥dulo, el estudiante
entender√° que:</p>
<ul>
<li>La inform√°tica no consiste solo en programar, sino en
<strong>dise√±ar soluciones eficientes</strong>.</li>
<li>Un problema mal resuelto puede ser inofensivo en peque√±a escala,
pero absolutamente desastroso cuando los datos se multiplican por
millones.</li>
<li>Los algoritmos y estructuras de datos son el puente entre la teor√≠a
matem√°tica y las aplicaciones pr√°cticas: desde buscadores web hasta
an√°lisis gen√≥micos, desde videojuegos hasta inteligencia
artificial.</li>
</ul>
<p>üìå <strong>Idea clave</strong>: Comprender algoritmos y estructuras
de datos es aprender a pensar c√≥mo resolver problemas de manera
sistem√°tica y √≥ptima. Es adquirir una caja de herramientas que podr√°s
aplicar en cualquier disciplina cient√≠fica, tecnol√≥gica o incluso en la
vida cotidiana.</p>
<hr />
<h2 id="concepto-y-representaci√≥n-de-algoritmos">2. Concepto y
representaci√≥n de algoritmos</h2>
<p>Un <strong>algoritmo</strong> es mucho m√°s que un conjunto de
instrucciones: es la <strong>esencia del pensamiento
computacional</strong>. Para que un procedimiento pueda considerarse
algoritmo, debe cumplir ciertas propiedades fundamentales:</p>
<ul>
<li><p><strong>Finitud</strong>: el algoritmo debe terminar siempre
despu√©s de un n√∫mero finito de pasos. Si no hay garant√≠a de terminaci√≥n,
no estamos ante un algoritmo, sino ante un proceso indefinido. üìå
<em>Ejemplo</em>: una receta de cocina tiene un final (el plato
preparado). En cambio, ‚Äúremueve indefinidamente la sopa‚Äù no cumple este
requisito.</p></li>
<li><p><strong>Definici√≥n precisa</strong>: cada paso debe estar
claramente especificado y no admitir ambig√ºedad. Los ordenadores no
saben interpretar ‚Äúun poco de sal‚Äù o ‚Äúmezclar hasta que est√© bien‚Äù.
Necesitan instrucciones exactas.</p></li>
<li><p><strong>Entrada y salida</strong>: todo algoritmo parte de unos
datos de entrada y produce resultados de salida. Sin entrada, el
algoritmo carece de sentido; sin salida, no resuelve nada.</p></li>
</ul>
<p>Estas propiedades permiten diferenciar los algoritmos de otros
procedimientos informales, como consejos, h√°bitos o descripciones
vagas.</p>
<hr />
<h3 id="representaci√≥n-de-algoritmos">2.1 Representaci√≥n de
algoritmos</h3>
<p>Un algoritmo puede representarse de varias formas, seg√∫n el contexto
y la audiencia:</p>
<ul>
<li><strong>Lenguaje natural</strong>: √∫til para explicar a
principiantes, pero propenso a ambig√ºedades.</li>
<li><strong>Diagramas de flujo</strong>: muy usados en las primeras
etapas de dise√±o; representan gr√°ficamente decisiones, procesos y
entradas/salidas.</li>
<li><strong>Pseudoc√≥digo</strong>: forma intermedia entre el lenguaje
natural y un lenguaje de programaci√≥n real. Permite expresar ideas con
claridad sin preocuparse de la sintaxis exacta.</li>
<li><strong>Lenguajes de programaci√≥n</strong>: cuando el objetivo es la
ejecuci√≥n por ordenador.</li>
</ul>
<h4 id="ejemplo-m√°ximo-de-n-n√∫meros">Ejemplo: m√°ximo de <em>n</em>
n√∫meros</h4>
<pre class="text"><code>Algoritmo Maximo(lista[1..n]):
  max ‚Üê lista[1]
  para i desde 2 hasta n hacer
    si lista[i] &gt; max entonces
      max ‚Üê lista[i]
  devolver max</code></pre>
<p>Este algoritmo recorre toda la lista una sola vez.</p>
<ul>
<li>N√∫mero de operaciones: proporcional a <em>n</em>.</li>
<li>Complejidad temporal: <strong>O(n)</strong>.</li>
<li>Complejidad espacial: <strong>O(1)</strong> (solo una variable
adicional <code>max</code>).</li>
</ul>
<p>üìå Este ejemplo sencillo ilustra c√≥mo analizar un algoritmo no solo
por su correcci√≥n, sino tambi√©n por su eficiencia.</p>
<hr />
<h2 id="an√°lisis-de-eficiencia-y-notaci√≥n-big-o">3. An√°lisis de
eficiencia y notaci√≥n Big O</h2>
<p>No todos los algoritmos que resuelven un mismo problema lo hacen con
la misma eficiencia. Por eso surge la necesidad de medir y comparar su
rendimiento.</p>
<p>La eficiencia se estudia en dos dimensiones principales:</p>
<ul>
<li><strong>Tiempo de ejecuci√≥n</strong>: cantidad de operaciones
realizadas en funci√≥n del tama√±o de la entrada (<em>n</em>).</li>
<li><strong>Uso de memoria</strong>: espacio adicional necesario para
ejecutar el algoritmo.</li>
</ul>
<p>Ejemplo motivador:</p>
<ul>
<li>Ordenar una lista de un mill√≥n de elementos con <strong>Bubble Sort
(O(n¬≤))</strong> es impracticable: tardar√≠a horas.</li>
<li>Con <strong>Merge Sort (O(n log n))</strong> la misma tarea se
resuelve en segundos.</li>
</ul>
<hr />
<h3 id="crecimiento-con-el-tama√±o-de-la-entrada">3.1 Crecimiento con el
tama√±o de la entrada</h3>
<p>La notaci√≥n Big O describe el comportamiento asint√≥tico de un
algoritmo: c√≥mo crece su tiempo o memoria requerida cuando <em>n</em> se
hace grande.</p>
<ul>
<li><strong>O(n)</strong>: tiempo lineal. Escala bien con datos
grandes.</li>
<li><strong>O(n¬≤)</strong>: tiempo cuadr√°tico. Factible solo con
vol√∫menes peque√±os.</li>
<li><strong>O(log n)</strong>: extremadamente eficiente; un mill√≥n de
elementos se resuelve en unas 20 operaciones.</li>
</ul>
<p><strong>Visualizaci√≥n del crecimiento de complejidades
comunes</strong>:</p>
<figure>
<img src="../images/complejidad.png" style="width:70.0%"
alt="Crecimiento de funciones de complejidad" />
<figcaption aria-hidden="true">Crecimiento de funciones de
complejidad</figcaption>
</figure>
<hr />
<h3 id="peor-caso-mejor-caso-y-caso-promedio">3.2 Peor caso, mejor caso
y caso promedio</h3>
<p>Analizar un algoritmo no es tan simple como medir un √∫nico
tiempo:</p>
<ul>
<li><strong>Peor caso</strong>: garantiza que el algoritmo nunca ser√°
peor que ese l√≠mite. Fundamental en contextos cr√≠ticos (ej. seguridad
inform√°tica).</li>
<li><strong>Mejor caso</strong>: refleja la situaci√≥n m√°s favorable (a
menudo poco representativa).</li>
<li><strong>Caso promedio</strong>: se calcula considerando la
distribuci√≥n estad√≠stica de las entradas. Muy √∫til en pr√°ctica
real.</li>
</ul>
<p>üìå <em>Ejemplo</em>:</p>
<ul>
<li><strong>QuickSort</strong> tiene un mejor caso y promedio de
<strong>O(n log n)</strong>, pero en el peor caso degenera a
<strong>O(n¬≤)</strong>.</li>
<li>Por eso se aplican estrategias como elegir pivotes aleatorios para
evitar los peores escenarios.</li>
</ul>
<hr />
<h3 id="paradigmas-algor√≠tmicos">3.3 Paradigmas algor√≠tmicos</h3>
<p>Los algoritmos no se dise√±an de manera aislada: suelen seguir
<strong>paradigmas de resoluci√≥n</strong> que sirven como gu√≠as
generales.</p>
<ul>
<li><strong>Divide y vencer√°s</strong>: divide un problema en
subproblemas m√°s peque√±os, resu√©lvelos y combina resultados. Ejemplo:
<em>Merge Sort</em>, b√∫squeda binaria.</li>
<li><strong>Voraces (greedy)</strong>: toman decisiones locales √≥ptimas
esperando llegar a la soluci√≥n global. Ejemplo: algoritmo de Kruskal
para √°rboles de expansi√≥n m√≠nima.</li>
<li><strong>Programaci√≥n din√°mica</strong>: almacena resultados
intermedios para no recalcular. Ejemplo: algoritmo de Needleman‚ÄìWunsch
para alineamiento global de secuencias.</li>
</ul>
<p>Estos paradigmas son el esqueleto de muchas soluciones modernas en
bioinform√°tica, optimizaci√≥n y teor√≠a de grafos.</p>
<hr />
<h3 id="tabla-de-complejidad-habitual">3.4 Tabla de complejidad
habitual</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 23%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>Orden</th>
<th>Descripci√≥n</th>
<th>Ejemplo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>O(1)</strong></td>
<td>Tiempo constante</td>
<td>Acceso a un elemento de un array</td>
</tr>
<tr class="even">
<td><strong>O(log n)</strong></td>
<td>Logar√≠tmico</td>
<td>B√∫squeda binaria</td>
</tr>
<tr class="odd">
<td><strong>O(n)</strong></td>
<td>Lineal</td>
<td>Recorrer un vector</td>
</tr>
<tr class="even">
<td><strong>O(n log n)</strong></td>
<td>Cuasilineal</td>
<td><em>Merge Sort</em>, <em>Quicksort</em></td>
</tr>
<tr class="odd">
<td><strong>O(n¬≤)</strong></td>
<td>Cuadr√°tico</td>
<td><em>Bubble Sort</em></td>
</tr>
<tr class="even">
<td><strong>O(2‚Åø)</strong></td>
<td>Exponencial</td>
<td>Problema de la mochila (fuerza bruta)</td>
</tr>
<tr class="odd">
<td><strong>O(n!)</strong></td>
<td>Factorial</td>
<td>Generaci√≥n de todas las permutaciones</td>
</tr>
</tbody>
</table>
<p>‚ö° Adem√°s de Big O, existen notaciones complementarias:</p>
<ul>
<li><strong>Œ©</strong>: cota inferior.</li>
<li><strong>Œò</strong>: cota ajustada (cuando superior e inferior
coinciden).</li>
</ul>
<hr />
<h2 id="ejemplos-aplicados-en-bioinform√°tica">4. Ejemplos aplicados en
bioinform√°tica</h2>
<p>La bioinform√°tica es un campo donde la eficiencia algor√≠tmica es
cr√≠tica:</p>
<ul>
<li><strong>C√°lculo del contenido GC</strong> en una secuencia de ADN.
Algoritmo lineal <strong>O(n)</strong>.</li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>seq <span class="op">=</span> <span class="st">&quot;ATGCGCTAAGC&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>gc <span class="op">=</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> base <span class="kw">in</span> seq <span class="cf">if</span> base <span class="kw">in</span> <span class="st">&quot;GC&quot;</span>) <span class="op">/</span> <span class="bu">len</span>(seq)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;GC%: </span><span class="sc">{</span>gc<span class="sc">:.2%}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<ul>
<li><strong>Comparaci√≥n de todas las parejas de secuencias</strong> en
un genoma: <strong>O(n¬≤)</strong>. Impracticable para genomas
completos.</li>
<li><strong>Alineamiento global</strong>: programaci√≥n din√°mica ‚Üí
<strong>O(n¬∑m)</strong> para dos secuencias de longitudes <em>n</em> y
<em>m</em>. Aunque costoso, es mucho m√°s eficiente que la comparaci√≥n
exhaustiva.</li>
<li><strong>BLAST</strong>: ejemplo de heur√≠stica que sacrifica
exactitud a cambio de tiempos cercanos a <strong>O(n)</strong>, lo que
lo hizo revolucionario en los a√±os 90.</li>
</ul>
<hr />
<h2 id="tipos-de-estructuras-de-datos">5. Tipos de estructuras de
datos</h2>
<p>Las estructuras de datos definen c√≥mo se organizan y almacenan los
datos en memoria.</p>
<h3 id="clasificaci√≥n-b√°sica">Clasificaci√≥n b√°sica</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 40%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>Tipo</th>
<th>Descripci√≥n</th>
<th>Ejemplo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Lineales</strong></td>
<td>Elementos en secuencia</td>
<td>vectores, listas, pilas, colas</td>
</tr>
<tr class="even">
<td><strong>Jer√°rquicas</strong></td>
<td>Relaciones en niveles</td>
<td>√°rboles, heaps</td>
</tr>
<tr class="odd">
<td><strong>Grafos</strong></td>
<td>Relaciones generales entre nodos</td>
<td>redes sociales, mapas</td>
</tr>
<tr class="even">
<td><strong>Est√°ticas</strong></td>
<td>Tama√±o fijo</td>
<td>arrays</td>
</tr>
<tr class="odd">
<td><strong>Din√°micas</strong></td>
<td>Tama√±o variable</td>
<td>listas enlazadas, √°rboles, grafos</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="tipos-de-dato-abstracto-tda">5.1 Tipos de Dato Abstracto
(TDA)</h3>
<p>Un <strong>TDA</strong> define el comportamiento esperado de una
estructura de datos sin entrar en c√≥mo se implementa.</p>
<p>Ejemplo: la <strong>pila</strong> (stack).</p>
<ul>
<li>Operaciones: <code>apilar</code>, <code>desapilar</code>,
<code>consultar</code>.</li>
<li>Implementaciones posibles: vector (eficiente en acceso), lista
enlazada (eficiente en inserci√≥n/eliminaci√≥n).</li>
</ul>
<p>üìå Separar concepto de implementaci√≥n permite dise√±ar programas m√°s
robustos y modulares.</p>
<hr />
<h2 id="vectores-y-matrices">6. Vectores y matrices</h2>
<p>Los <strong>vectores (arrays)</strong> son la estructura m√°s b√°sica
y, a la vez, una de las m√°s poderosas:</p>
<ul>
<li><strong>Acceso aleatorio</strong>: O(1).</li>
<li><strong>Recorrido completo</strong>: O(n).</li>
<li><strong>Inserciones o eliminaciones en medio</strong>: O(n), por el
coste de mover elementos.</li>
</ul>
<p>Las <strong>matrices</strong> (arrays bidimensionales) permiten
representar informaci√≥n tabular o espacial:</p>
<ul>
<li>Imagen digital: cada p√≠xel es una celda de la matriz.</li>
<li>Tabla de expresi√≥n gen√©tica: filas como genes, columnas como
condiciones experimentales.</li>
</ul>
<p>üîç Ejemplo pr√°ctico: recorrer una matriz por filas suele ser m√°s
r√°pido que por columnas porque aprovecha la <strong>localidad de
cach√©</strong> de la CPU. Esto ilustra c√≥mo los detalles de hardware
influyen en el rendimiento.</p>
<hr />
<h2 id="conclusiones">7. Conclusiones</h2>
<p>En esta parte hemos:</p>
<ul>
<li>Definido los requisitos de un algoritmo.</li>
<li>Visto c√≥mo representarlos en pseudoc√≥digo y diagramas de flujo.</li>
<li>Aprendido a medir su eficiencia con Big O y otras notaciones.</li>
<li>Exploramos paradigmas algor√≠tmicos y su relevancia en problemas
reales.</li>
<li>Introducimos la clasificaci√≥n de estructuras de datos y el concepto
de TDA.</li>
<li>Introducimos vectores y matrices como estructuras est√°ticas
fundamentales.</li>
</ul>
<p>üìå Entender estos conceptos es adquirir el lenguaje b√°sico con el que
se construyen todos los sistemas inform√°ticos modernos.</p>
<hr />
<h2 id="ejercicios-de-autoevaluaci√≥n">8. Ejercicios de
autoevaluaci√≥n</h2>
<ol type="1">
<li>Explica con tus palabras por qu√© un algoritmo debe ser finito. Da un
ejemplo de procedimiento no finito.</li>
<li>Representa en pseudoc√≥digo un algoritmo que busque el m√≠nimo de una
lista. ¬øCu√°l es su complejidad temporal?</li>
<li>¬øQu√© diferencia pr√°ctica hay entre un algoritmo O(n) y otro O(n log
n) para <em>n = 1.000.000</em>?</li>
<li>Explica por qu√© QuickSort se considera eficiente a pesar de tener un
peor caso O(n¬≤).</li>
<li>¬øC√≥mo implementar√≠as una pila con un vector? ¬øY con una lista
enlazada? ¬øQu√© ventajas e inconvenientes observas?</li>
<li>Dise√±a un ejemplo donde recorrer una matriz por filas sea m√°s
eficiente que por columnas y explica por qu√©.</li>
</ol>
<hr />
<h2 id="referencias">Referencias</h2>
<ul>
<li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C.
<em>Introduction to Algorithms</em>. MIT Press.</li>
<li>Sedgewick, R., &amp; Wayne, K. <em>Algorithms</em>.
Addison-Wesley.</li>
<li>Goodrich, M. T., &amp; Tamassia, R. <em>Data Structures and
Algorithms in Java</em>. Wiley.</li>
<li>Kleinberg, J., &amp; Tardos, √â. <em>Algorithm Design</em>.
Pearson.</li>
<li>Gusfield, D. <em>Algorithms on Strings, Trees and Sequences</em>.
Cambridge University Press (bioinform√°tica).</li>
</ul>
