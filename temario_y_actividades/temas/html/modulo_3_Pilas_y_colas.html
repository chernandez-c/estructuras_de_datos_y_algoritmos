<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Curso de Introducci√≥n a Estructuras de Datos y Algoritmos" />
  <title>M√≥dulo 3 ‚Äì Pilas y colas</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">M√≥dulo 3 ‚Äì Pilas y colas</h1>
<p class="author">Curso de Introducci√≥n a Estructuras de Datos y Algoritmos</p>
<p class="date">21 de agosto de 2025</p>
</header>
<nav id="TOC" role="doc-toc">

</nav>
<h1 id="m√≥dulo-3-pilas-y-colas-gestionando-el-orden-en-la-complejidad">M√≥dulo 3 ‚Äì Pilas y Colas: Gestionando el Orden en la Complejidad</h1>
<h2 id="motivaci√≥n-el-poder-de-las-restricciones">Motivaci√≥n: El Poder de las Restricciones</h2>
<p>Antes de sumergirnos en la implementaci√≥n, es crucial preguntarse: ¬øpor qu√© querr√≠amos limitar nuestro acceso a los datos? En un mundo donde las listas y los arrays nos dan la libertad de acceder a cualquier elemento por su √≠ndice (<code>array[i]</code>), las pilas y colas parecen un paso atr√°s.</p>
<p>La respuesta reside en una poderosa filosof√≠a de dise√±o de software: <strong>la restricci√≥n como herramienta para la simplicidad y la seguridad</strong>.</p>
<ol type="1">
<li><strong>Reducci√≥n de la Complejidad Cognitiva</strong>: Al limitar las operaciones a <code>push/pop</code> o <code>enqueue/dequeue</code>, el programador no tiene que pensar en todos los posibles estados de la estructura. El comportamiento es predecible y f√°cil de razonar. Esto es como las marchas de un coche: en lugar de controlar la rotaci√≥n del motor directamente, usamos una abstracci√≥n (primera, segunda, etc.) que simplifica la conducci√≥n.</li>
<li><strong>Prevenci√≥n de Errores</strong>: Imponer un orden de acceso estricto (LIFO o FIFO) evita errores comunes, como modificar un elemento en medio de una colecci√≥n mientras se est√° procesando o acceder a datos en el orden incorrecto en un sistema concurrente.</li>
<li><strong>Modelado del Mundo Real</strong>: Muchas procesos del mundo real son inherentemente LIFO o FIFO. Las pilas y colas no son invenciones abstractas, sino <strong>modelos matem√°ticos de procesos reales</strong>:
<ul>
<li>La pila de llamadas de un programa refleja c√≥mo las tareas se anidan y resuelven.</li>
<li>Una cola de impresi√≥n refleja el principio de justicia de ‚Äúel primero que llega, es el primero en ser servido‚Äù.</li>
</ul></li>
</ol>
<p>Al adoptar estas restricciones, ganamos claridad, robustez y algoritmos que son un reflejo fiel de los problemas que intentan solucionar.</p>
<hr />
<h2 id="pilas-stacks-la-memoria-del-presente-reciente">Pilas (Stacks): La Memoria del Presente Reciente</h2>
<p>Una <strong>pila</strong> es una estructura de datos que opera bajo el principio <strong>LIFO (Last-In, First-Out)</strong>. Su analog√≠a m√°s famosa es una pila de platos: solo puedes interactuar con el plato que est√° en la cima. Esta estructura es fundamental para gestionar procesos que tienen una naturaleza jer√°rquica o recursiva, donde la tarea m√°s reciente debe ser la primera en resolverse.</p>
<h3 id="operaciones-principales-y-casos-l√≠mite">Operaciones Principales y Casos L√≠mite</h3>
<p>Las operaciones definen la ‚Äúpersonalidad‚Äù de la pila. Es crucial entender no solo lo que hacen, sino tambi√©n sus condiciones de error.</p>
<ul>
<li><strong><code>apilar</code> (push)</strong>: A√±ade un elemento a la cima de la pila.
<ul>
<li><strong>Caso L√≠mite</strong>: Si la pila est√° implementada con un array de tama√±o fijo y ya est√° llena, se produce un error de <strong>desbordamiento de pila (Stack Overflow)</strong>. Este es uno de los errores m√°s famosos de la programaci√≥n.</li>
</ul></li>
<li><strong><code>desapilar</code> (pop)</strong>: Elimina el elemento de la cima y lo devuelve.
<ul>
<li><strong>Caso L√≠mite</strong>: Si se intenta desapilar un elemento de una pila vac√≠a, se produce un error de <strong>subdesbordamiento (Stack Underflow)</strong>. El programa debe gestionar esta situaci√≥n para evitar un comportamiento indefinido.</li>
</ul></li>
<li><strong><code>consultar</code> (peek/top)</strong>: Devuelve el elemento de la cima sin modificar la pila. Es una operaci√≥n de solo lectura.</li>
<li><strong><code>vac√≠a</code> (isEmpty)</strong>: Booleano que indica si la pila no contiene elementos.</li>
<li><strong><code>tama√±o</code> (size)</strong>: Devuelve el n√∫mero de elementos actualmente en la pila.</li>
</ul>
<h4 id="pseudoc√≥digo-b√°sico">Pseudoc√≥digo b√°sico</h4>
<pre class="text"><code>procedimiento apilar(PILA P, DATO x):
    P.tope ‚Üê P.tope + 1
    P.elementos[P.tope] ‚Üê x

DATO desapilar(PILA P):
    si P.tope = 0 entonces error &quot;Pila vac√≠a&quot;
    x ‚Üê P.elementos[P.tope]
    P.tope ‚Üê P.tope - 1
    devolver x</code></pre>
<p>###. An√°lisis Detallado de Implementaciones</p>
<p>La elecci√≥n de la implementaci√≥n subyacente (array o lista enlazada) tiene implicaciones en el rendimiento y el uso de memoria.</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 41%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th>Caracter√≠stica</th>
<th>Implementaci√≥n con Vector (Array)</th>
<th>Implementaci√≥n con Lista Enlazada</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rendimiento</strong></td>
<td><span class="math inline">\(O(1)\)</span> amortizado. Las operaciones son muy r√°pidas.</td>
<td><span class="math inline">\(O(1)\)</span> garantizado. Siempre es una operaci√≥n constante.</td>
</tr>
<tr class="even">
<td><strong>Uso de Memoria</strong></td>
<td>Puede desperdiciar memoria si se reserva m√°s de la necesaria.</td>
<td>M√°s eficiente: solo usa la memoria que necesita.</td>
</tr>
<tr class="odd">
<td><strong>Overhead de Memoria</strong></td>
<td>M√≠nimo (solo el array y un √≠ndice <code>tope</code>).</td>
<td>Mayor: cada elemento necesita un puntero adicional (<code>siguiente</code>).</td>
</tr>
<tr class="even">
<td><strong>Localidad de Cach√©</strong></td>
<td><strong>Excelente</strong>. Los elementos est√°n contiguos en memoria.</td>
<td><strong>Pobre</strong>. Los nodos pueden estar dispersos por la memoria.</td>
</tr>
<tr class="odd">
<td><strong>Flexibilidad</strong></td>
<td>Tama√±o fijo (a menos que se use un array din√°mico, con coste).</td>
<td>Din√°mica y flexible por naturaleza.</td>
</tr>
</tbody>
</table>
<p><strong>Conclusi√≥n Filos√≥fica</strong>: La implementaci√≥n con <strong>vector</strong> es preferible cuando el tama√±o m√°ximo es conocido o predecible y el rendimiento es cr√≠tico (gracias a la cach√©). La <strong>lista enlazada</strong> es ideal para situaciones donde el tama√±o es impredecible y la flexibilidad es la m√°xima prioridad.</p>
<p>###. Caso de Estudio a Fondo: La Pila de Llamadas (Call Stack)</p>
<p>Quiz√°s la aplicaci√≥n m√°s importante de las pilas es la <strong>gesti√≥n de la pila de llamadas a funciones</strong> en casi todos los lenguajes de programaci√≥n modernos. Sin ella, la recursi√≥n y la propia estructura de nuestros programas ser√≠an imposibles.</p>
<p><strong>¬øC√≥mo funciona?</strong></p>
<ol type="1">
<li><strong>Programa Principal</strong>: El sistema operativo crea un ‚Äúmarco de pila‚Äù (stack frame) para la funci√≥n <code>main()</code>. Este marco contiene sus variables locales y la direcci√≥n de retorno.</li>
<li><strong>Llamada a Funci√≥n</strong>: Cuando <code>main()</code> llama a <code>funcionA()</code>, se crea un nuevo marco para <code>funcionA</code> y se apila <strong>encima</strong> del de <code>main()</code>.</li>
<li><strong>Llamadas Anidadas</strong>: Si <code>funcionA()</code> llama a <code>funcionB()</code>, se apila un nuevo marco para <code>funcionB</code> en la cima.</li>
<li><strong>Retorno</strong>: Cuando <code>funcionB()</code> termina, su marco se <strong>desapila</strong>. El control vuelve a <code>funcionA()</code>, que ahora est√° de nuevo en la cima.</li>
<li><strong>Fin</strong>: El proceso contin√∫a hasta que todas las funciones han retornado y la pila vuelve a estar vac√≠a (solo con <code>main</code>, que al terminar devuelve el control al SO).</li>
</ol>
<p><strong>Diagrama conceptual:</strong></p>
<pre><code>      Pila:
    | Marco funcionB | &lt;-- Cima (en ejecuci√≥n)
    |----------------|
    | Marco funcionA |
    |----------------|
    | Marco main()   |
    +----------------+</code></pre>
<p>Este mecanismo es la raz√≥n por la que una recursi√≥n infinita causa un error de <strong>Stack Overflow</strong>: cada llamada recursiva apila un nuevo marco hasta que se agota la memoria asignada a la pila.</p>
<figure>
<img src="../../images/stack.png" alt="" /><figcaption>Representaci√≥n de una pila</figcaption>
</figure>
<p><em>Figura 5: estructura LIFO.</em></p>
<p>üìå <em>Filosof√≠a</em>: la pila nos ense√±a que <strong>la historia reciente es la m√°s importante</strong>: lo √∫ltimo que hicimos es lo primero que podemos deshacer.</p>
<hr />
<h2 id="colas-queues-la-justicia-del-orden-de-llegada">Colas (Queues): La Justicia del Orden de Llegada</h2>
<p>Una <strong>cola</strong> implementa el principio <strong>FIFO (First-In, First-Out)</strong>. Es el modelo de la fila de un supermercado: la primera persona en llegar es la primera en ser atendida. Este principio de justicia y orden secuencial es clave para sistemas que gestionan recursos compartidos o procesan tareas en el orden en que fueron solicitadas.</p>
<h3 id="operaciones-principales">Operaciones Principales</h3>
<ul>
<li><strong><code>encolar</code> (enqueue)</strong>: A√±ade un elemento al <strong>final</strong> de la cola.</li>
<li><strong><code>desencolar</code> (dequeue)</strong>: Elimina el elemento del <strong>principio</strong> de la cola y lo devuelve.</li>
<li><strong><code>frente</code> (front/peek)</strong>: Consulta el primer elemento sin retirarlo.</li>
<li><strong><code>vac√≠a</code> (isEmpty)</strong>: Indica si la cola est√° vac√≠a.</li>
</ul>
<h4 id="pseudoc√≥digo-b√°sico-1">Pseudoc√≥digo b√°sico</h4>
<pre class="text"><code>procedimiento encolar(COLA Q, DATO x):
    Q.trasero ‚Üê Q.trasero + 1
    Q.elementos[Q.trasero] ‚Üê x

DATO desencolar(COLA Q):
    si Q.frente &gt; Q.trasero entonces error &quot;Cola vac√≠a&quot;
    x ‚Üê Q.elementos[Q.frente]
    Q.frente ‚Üê Q.frente + 1
    devolver x</code></pre>
<h3 id="implementaciones-y-el-desaf√≠o-de-la-cola-circular">Implementaciones y el Desaf√≠o de la Cola Circular</h3>
<p><strong>El Problema de la Implementaci√≥n con Vector Simple:</strong></p>
<p>Si usamos un vector con dos punteros, <code>frente</code> y <code>trasero</code>, nos encontramos con un problema. A medida que encolamos y desencolamos, ambos punteros avanzan. Eventualmente, <code>trasero</code> llegar√° al final del array, y no podremos a√±adir m√°s elementos, <strong>incluso si hay espacio libre al principio</strong> (dejado por los elementos desencolados).</p>
<p><strong>La Soluci√≥n Elegante: La Cola Circular</strong></p>
<p>La cola circular resuelve esto tratando el array como si fuera un c√≠rculo. Cuando un puntero llega al final, simplemente ‚Äúda la vuelta‚Äù y contin√∫a desde el principio.</p>
<p>Esto se logra con la <strong>aritm√©tica modular</strong>. Para un array de tama√±o <span class="math inline">\(N\)</span>:</p>
<ul>
<li>Para avanzar el puntero <code>trasero</code>: <code>trasero = (trasero + 1) % N</code></li>
<li>Para avanzar el puntero <code>frente</code>: <code>frente = (frente + 1) % N</code></li>
</ul>
<p>Este dise√±o es incre√≠blemente eficiente y es el est√°ndar para implementar buffers de tama√±o fijo en sistemas operativos, redes y hardware.</p>
<h3 id="variantes-de-colas">Variantes de Colas</h3>
<ul>
<li><strong>Cola Circular</strong>: Como se vio, es una optimizaci√≥n para implementaciones con arrays. Es la base de los <em>ring buffers</em>.</li>
<li><strong>Deque (Cola Doble)</strong>: Del ingl√©s <em>Double-Ended Queue</em>. Es una estructura h√≠brida que permite <strong>encolar y desencolar por ambos extremos</strong>. Es una navaja suiza de las estructuras lineales, √∫til en algoritmos de ventanas deslizantes (<em>sliding window</em>) o para construir otros algoritmos m√°s complejos.</li>
<li><strong>Cola de Prioridad</strong>: Rompe la regla FIFO. Cada elemento tiene una <strong>prioridad</strong> asociada. Al desencolar, siempre se extrae el elemento con la m√°xima prioridad, sin importar cu√°ndo lleg√≥. No se implementa con arrays o listas, sino con estructuras m√°s complejas como los <strong>heaps (mont√≠culos)</strong>. Son esenciales en algoritmos como el de Dijkstra (para encontrar el camino m√°s corto en un grafo) o en la planificaci√≥n de procesos de un SO donde algunas tareas son m√°s urgentes que otras.</li>
</ul>
<h3 id="caso-de-estudio-a-fondo-el-planificador-de-procesos-del-sistema-operativo">Caso de Estudio a Fondo: El Planificador de Procesos del Sistema Operativo</h3>
<p>Los sistemas operativos modernos son multitarea, lo que significa que pueden ejecutar m√∫ltiples procesos (casi) simult√°neamente. ¬øC√≥mo decide la CPU a qu√© proceso prestarle atenci√≥n en cada momento? La respuesta m√°s simple es una <strong>cola de procesos listos (Ready Queue)</strong>.</p>
<ol type="1">
<li><p><strong>Llegada de Procesos</strong>: Cuando un programa se lanza (ej., abres un navegador), el SO crea un Proceso y lo <strong>encola</strong> en la cola de procesos listos.</p></li>
<li><p><strong>Planificaci√≥n (Scheduling)</strong>: El <strong>planificador</strong> de la CPU es un componente del SO que toma el primer proceso de la cola (<code>desencolar</code>).</p></li>
<li><p><strong>Ejecuci√≥n</strong>: La CPU ejecuta ese proceso durante un breve intervalo de tiempo llamado <em>quantum</em>.</p></li>
<li><p><strong>Re-encolado o Finalizaci√≥n</strong>:</p>
<ul>
<li>Si el proceso no ha terminado al final de su <em>quantum</em>, es interrumpido y <strong>vuelve a ser encolado</strong> al final de la fila para esperar su pr√≥ximo turno (esto se conoce como <em>Round-Robin</em>).</li>
<li>Si el proceso termina o necesita esperar por una operaci√≥n (ej., leer un archivo), se retira de la cola.</li>
</ul></li>
</ol>
<p>Este sistema basado en colas garantiza la <strong>equidad (fairness)</strong>: cada proceso tiene la oportunidad de ejecutarse, evitando que un solo proceso monopolice la CPU.</p>
<figure>
<img src="../../images/queue.png" alt="" /><figcaption>Representaci√≥n de una cola</figcaption>
</figure>
<p><em>Figura 6: estructura FIFO.</em></p>
<hr />
<h2 id="contexto-hist√≥rico-y-or√≠genes-conceptuales">Contexto Hist√≥rico y Or√≠genes Conceptuales</h2>
<p>Las pilas y colas no nacieron con la inform√°tica moderna; son conceptos que los matem√°ticos y l√≥gicos ya utilizaban.</p>
<ul>
<li><strong>Notaci√≥n Polaca Inversa (RPN)</strong>: En la d√©cada de 1920, el l√≥gico polaco Jan ≈Åukasiewicz desarroll√≥ una notaci√≥n matem√°tica que no requer√≠a par√©ntesis. Esta notaci√≥n (ej. <code>3 4 +</code> en lugar de <code>3 + 4</code>) es trivial de evaluar con una pila y fue la base de las famosas calculadoras cient√≠ficas de <strong>Hewlett-Packard (HP)</strong> en los a√±os 70, que se ganaron una legi√≥n de fans por su eficiencia.</li>
<li><strong>Primeros Lenguajes</strong>: Alan Turing ya teoriz√≥ sobre una ‚Äúpila‚Äù para llamadas a subrutinas en sus dise√±os de m√°quinas. Los primeros lenguajes de alto nivel como <strong>Lisp y Fortran</strong> implementaron pilas para gestionar la recursi√≥n y las llamadas a funciones, sentando las bases de c√≥mo funcionan los lenguajes hoy en d√≠a.</li>
<li><strong>Spooling y Sistemas Operativos</strong>: El concepto de cola se formaliz√≥ en los sistemas operativos de los a√±os 60. El t√©rmino <strong>spooling</strong> (<em>Simultaneous Peripheral Operations On-Line</em>) se acu√±√≥ para describir el sistema que usaba colas para gestionar trabajos de impresi√≥n en un disco intermedio, liberando a la CPU para otras tareas. Este fue uno de los primeros ejemplos de procesamiento as√≠ncrono, una idea fundamental en la computaci√≥n moderna.</li>
</ul>
<hr />
<h2 id="conclusiones-m√°s-all√°-de-la-implementaci√≥n">Conclusiones: M√°s All√° de la Implementaci√≥n</h2>
<p>Las pilas y colas son mucho m√°s que simples formas de organizar datos. Son <strong>abstracciones fundamentales</strong> que nos ense√±an a pensar sobre el flujo del tiempo y el orden en los algoritmos.</p>
<ul>
<li><strong>Pila</strong>: Gobierna la <strong>profundidad</strong>, la recursi√≥n y el retroceso (<em>backtracking</em>). Es la estructura de ‚Äúir por un camino, y si no funciona, volver sobre tus pasos‚Äù.</li>
<li><strong>Cola</strong>: Gobierna la <strong>amplitud</strong>, el reparto justo de recursos y el procesamiento secuencial. Es la estructura de ‚Äúatender a todos en orden, nivel por nivel‚Äù.</li>
</ul>
<p>Comprender su disciplina de acceso es el primer paso para dominar algoritmos m√°s complejos de grafos (DFS usa una pila, BFS usa una cola), sistemas concurrentes y dise√±o de sistemas operativos. Representan dos formas primordiales de gestionar tareas: una que prioriza lo √∫ltimo y otra que respeta el orden hist√≥rico.</p>
<hr />
<h2 id="ejercicios-ampliados">Ejercicios Ampliados</h2>
<h4 id="ejercicios-te√≥ricos-y-de-dise√±o">Ejercicios Te√≥ricos y de Dise√±o</h4>
<ol type="1">
<li>Dibuja el estado de una pila y una cola despu√©s de la siguiente secuencia de operaciones: <code>push(A)</code>, <code>enqueue(B)</code>, <code>push(C)</code>, <code>dequeue()</code>, <code>pop()</code>, <code>enqueue(D)</code>.</li>
<li>Explica por qu√© una cola de prioridad no puede ser implementada eficientemente con una simple lista enlazada si se quiere mantener un rendimiento √≥ptimo en las operaciones.</li>
<li>Dise√±a un algoritmo que utilice dos colas para simular el comportamiento de una pila. Analiza la complejidad de tus operaciones <code>push</code> y <code>pop</code>.</li>
</ol>
<h4 id="ejercicios-pr√°cticos-de-programaci√≥n">Ejercicios Pr√°cticos de Programaci√≥n</h4>
<ol start="4" type="1">
<li><strong>Verificador de Par√©ntesis</strong>: Escribe una funci√≥n que reciba una cadena con par√©ntesis <code>()</code>, corchetes <code>[]</code> y llaves <code>{}</code> y determine si est√°n balanceados. (Pista: usa una pila).</li>
<li><strong>Simulador de Hot-Potato</strong>: Implementa el juego de la ‚Äúpatata caliente‚Äù. Un grupo de ni√±os se pasa una patata. Cada N pases, el ni√±o que la tiene es eliminado. El √∫ltimo que queda, gana. (Pista: una cola circular es perfecta para esto).</li>
<li><strong>Implementa una Deque</strong>: Crea una clase <code>Deque</code> utilizando una lista doblemente enlazada como estructura subyacente, con operaciones <code>addFirst</code>, <code>addLast</code>, <code>removeFirst</code>, <code>removeLast</code>.</li>
</ol>
<hr />
<h2 id="referencias">Referencias</h2>
<ul>
<li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. <em>Introduction to Algorithms</em>. MIT Press.</li>
<li>Goodrich, M. T., Tamassia, R., &amp; Goldwasser, M. H. <em>Data Structures and Algorithms in Python</em>. Wiley.</li>
<li>Weiss, M. A. <em>Data Structures and Algorithm Analysis</em>. Pearson.</li>
<li>Sedgewick, R., &amp; Wayne, K. <em>Algorithms</em>. Addison-Wesley.</li>
<li>Knuth, D. <em>The Art of Computer Programming, Vol. 1: Fundamental Algorithms</em>. Addison-Wesley.</li>
</ul>
<hr />
</body>
</html>
