<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Curso de Introducci√≥n a Estructuras de Datos y Algoritmos" />
  <title>M√≥dulo 2 ‚Äì Listas enlazadas</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="/usr/share/javascript/mathjax/MathJax.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">M√≥dulo 2 ‚Äì Listas enlazadas</h1>
<p class="author">Curso de Introducci√≥n a Estructuras de Datos y
Algoritmos</p>
<p class="date">21 de agosto de 2025</p>
</header>
<nav id="TOC" role="doc-toc">

</nav>
<h1 id="m√≥dulo-2-listas-enlazadas">M√≥dulo 2 ‚Äì Listas enlazadas</h1>
<hr />
<h2 id="introducci√≥n">Introducci√≥n</h2>
<p>En el m√≥dulo anterior vimos que los <strong>vectores
(arrays)</strong> son estructuras de datos muy √∫tiles cuando queremos
<strong>acceder r√°pidamente a un elemento cualquiera</strong> mediante
su √≠ndice. Esta eficiencia, sin embargo, viene con un precio: su tama√±o
es <strong>fijo</strong>. Si declaramos un vector de tama√±o 10, ni
podemos ampliarlo m√°gicamente a 100, ni reducirlo a 5 sin crear otro en
memoria.</p>
<p>üìå <strong>Problema motivador</strong>: imagina que gestionas un
programa de edici√≥n gen√©tica en el que las bases de ADN se van
insertando o eliminando de forma din√°mica. Con arrays, cada modificaci√≥n
implica desplazar miles de posiciones en memoria. Con listas enlazadas,
basta con ajustar un par de punteros.</p>
<p>Para superar las limitaciones de los vectores aparecen las
<strong>listas enlazadas</strong>. Una lista enlazada es una estructura
din√°mica en la que cada elemento (o <strong>nodo</strong>) contiene:</p>
<ul>
<li>La informaci√≥n (dato).</li>
<li>Una referencia (puntero o enlace) hacia el siguiente nodo.</li>
</ul>
<p>De esta manera, el tama√±o de la lista se <strong>adapta en tiempo de
ejecuci√≥n</strong>: podemos a√±adir y quitar nodos sin necesidad de
reservar o liberar grandes bloques contiguos de memoria.</p>
<hr />
<h2 id="estructura-de-una-lista-enlazada-simple">1. Estructura de una
lista enlazada simple</h2>
<p>Una <strong>lista enlazada simple</strong> est√° formada por nodos
conectados uno tras otro. Cada nodo tiene dos campos:</p>
<ol type="1">
<li><strong>Dato</strong>: la informaci√≥n que queremos almacenar
(n√∫meros, cadenas, estructuras).</li>
<li><strong>Enlace</strong>: un puntero que indica la direcci√≥n del
siguiente nodo.</li>
</ol>
<p>El primer nodo se denomina <strong>cabeza</strong> (<em>head</em>), y
el √∫ltimo nodo apunta a <code>null</code>, se√±alando el final de la
lista.</p>
<figure>
<img src="../images/linked_list.png" style="width:80.0%"
alt="Lista enlazada simple" />
<figcaption aria-hidden="true">Lista enlazada simple</figcaption>
</figure>
<p><em>Figura 2: lista enlazada simple de cinco nodos.</em></p>
<h3 id="operaciones-b√°sicas-y-coste">1.1 Operaciones b√°sicas y
coste</h3>
<ul>
<li><strong>Inserci√≥n al inicio</strong> ‚Üí <span
class="math inline">\(O(1)\)</span> Basta con redirigir el puntero de la
cabeza.</li>
<li><strong>Inserci√≥n al final</strong> ‚Üí <span
class="math inline">\(O(n)\)</span> Necesitamos recorrer toda la lista
hasta el √∫ltimo nodo.</li>
<li><strong>Inserci√≥n intermedia</strong> ‚Üí <span
class="math inline">\(O(n)\)</span> Hay que llegar a la posici√≥n
deseada.</li>
<li><strong>Eliminaci√≥n</strong> ‚Üí <span
class="math inline">\(O(1)\)</span> si es la cabeza; <span
class="math inline">\(O(n)\)</span> si est√° en medio (hay que conocer el
nodo anterior).</li>
<li><strong>B√∫squeda</strong> ‚Üí <span
class="math inline">\(O(n)\)</span>, porque no existe acceso
aleatorio.</li>
</ul>
<h4 id="pseudoc√≥digo-de-inserci√≥n-al-inicio">Pseudoc√≥digo de inserci√≥n
al inicio</h4>
<pre class="text"><code>NODO insertarInicio(LISTA L, DATO x):
    nuevo ‚Üê crearNodo(x)
    nuevo.siguiente ‚Üê L.cabeza
    L.cabeza ‚Üê nuevo</code></pre>
<h4 id="pseudoc√≥digo-de-b√∫squeda">Pseudoc√≥digo de b√∫squeda</h4>
<pre class="text"><code>NODO buscar(LISTA L, DATO x):
    actual ‚Üê L.cabeza
    mientras actual ‚â† null hacer
        si actual.dato = x entonces
            devolver actual
        actual ‚Üê actual.siguiente
    devolver null</code></pre>
<p>La lista enlazada simple nos recuerda que <strong>a veces el camino
importa m√°s que la meta</strong>. Para llegar al nodo 5, no podemos
saltar, debemos recorrer la lista paso a paso, como quien lee una novela
p√°gina a p√°gina.</p>
<hr />
<h2 id="listas-doblemente-enlazadas">2. Listas doblemente enlazadas</h2>
<p>Una mejora importante es la <strong>lista doblemente
enlazada</strong>. Aqu√≠ cada nodo guarda tres campos:</p>
<ul>
<li>El <strong>dato</strong>.</li>
<li>Un <strong>puntero al siguiente</strong>.</li>
<li>Un <strong>puntero al anterior</strong>.</li>
</ul>
<p>Esto permite recorrer la lista en <strong>ambos sentidos</strong> y
facilita operaciones como eliminar un nodo sin necesidad de conocer a su
predecesor.</p>
<figure>
<img src="../images/doubly_linked_list.png" style="width:80.0%"
alt="Lista doblemente enlazada" />
<figcaption aria-hidden="true">Lista doblemente enlazada</figcaption>
</figure>
<p><em>Figura 3: lista doblemente enlazada.</em></p>
<p>‚ö° Inconveniente: se necesita m√°s memoria por nodo y m√°s trabajo al
insertar (hay que actualizar dos punteros en vez de uno).</p>
<p>üìú <strong>An√©cdota hist√≥rica</strong>: las primeras implementaciones
de editores de texto en los a√±os 70 (como <em>EMACS</em>) usaban listas
doblemente enlazadas para representar l√≠neas de texto, porque resultaba
natural moverse hacia adelante y atr√°s en el documento.</p>
<hr />
<h2 id="listas-circulares">3. Listas circulares</h2>
<p>En una <strong>lista circular</strong>, el √∫ltimo nodo no apunta a
<code>null</code> sino de nuevo al primero. De esta forma, el recorrido
nunca se detiene: no existe un ‚Äúfinal‚Äù.</p>
<p>Caracter√≠sticas:</p>
<ul>
<li>La <strong>cabeza</strong> puede ser cualquier nodo.</li>
<li>Mantener un puntero al √∫ltimo nodo permite insertar al inicio y al
final en tiempo constante.</li>
</ul>
<figure>
<img src="../images/circular_linked_list.png" style="width:65.0%"
alt="Lista circular" />
<figcaption aria-hidden="true">Lista circular</figcaption>
</figure>
<p><em>Figura 4: lista enlazada circular.</em></p>
<h3 id="aplicaciones-t√≠picas">Aplicaciones t√≠picas</h3>
<ul>
<li><strong>Planificadores de CPU</strong> (algoritmo round-robin).</li>
<li><strong>Listas de reproducci√≥n de m√∫sica</strong> que vuelven al
inicio.</li>
<li><strong>Juegos de mesa</strong> donde los turnos son c√≠clicos.</li>
</ul>
<p>Tambi√©n existen <strong>listas doblemente circulares</strong>, que
permiten navegar hacia adelante y atr√°s sin l√≠mites.</p>
<hr />
<h2 id="comparaci√≥n-con-arrays">4. Comparaci√≥n con arrays</h2>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 47%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Caracter√≠stica</th>
<th>Lista enlazada</th>
<th>Vector (array)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Crecimiento</strong></td>
<td>Din√°mico, tama√±o ajustable en tiempo de ejecuci√≥n.</td>
<td>Est√°tico, tama√±o fijo.</td>
</tr>
<tr class="even">
<td><strong>Acceso aleatorio</strong></td>
<td>No, recorrido secuencial <span
class="math inline">\(O(n)\)</span>.</td>
<td>S√≠, acceso <span class="math inline">\(O(1)\)</span> mediante
√≠ndices.</td>
</tr>
<tr class="odd">
<td><strong>Inserci√≥n/eliminaci√≥n</strong></td>
<td><span class="math inline">\(O(1)\)</span> si se conoce el nodo;
<span class="math inline">\(O(n)\)</span> si hay que recorrer.</td>
<td><span class="math inline">\(O(n)\)</span> (desplazamiento de
elementos).</td>
</tr>
<tr class="even">
<td><strong>Uso de memoria</strong></td>
<td>Requiere punteros adicionales.</td>
<td>M√°s compacta y contigua.</td>
</tr>
<tr class="odd">
<td><strong>Localidad de referencia</strong></td>
<td>Baja: nodos dispersos en memoria.</td>
<td>Alta: aprovecha mejor la cach√©.</td>
</tr>
</tbody>
</table>
<p><strong>Conclusi√≥n pr√°ctica</strong>:</p>
<ul>
<li>Usa <strong>listas enlazadas</strong> si habr√° muchas inserciones y
eliminaciones.</li>
<li>Usa <strong>arrays</strong> si necesitas acceso r√°pido por √≠ndice y
mejor rendimiento en cach√©.</li>
</ul>
<p>üìå Filosof√≠a: la elecci√≥n de la estructura de datos depende del
<strong>patr√≥n de uso</strong>, no de una ‚Äúmejor‚Äù universal.</p>
<hr />
<h2 id="casos-de-uso-en-bioinform√°tica-y-computaci√≥n">5. Casos de uso en
bioinform√°tica y computaci√≥n</h2>
<ul>
<li><strong>Gesti√≥n din√°mica de secuencias</strong>: en ediciones de
ADN, cuando se insertan o eliminan bases constantemente.</li>
<li><strong>Colas de procesos</strong>: en sistemas operativos, donde
los procesos entran y salen de forma continua.</li>
<li><strong>Modelado molecular din√°mico</strong>: los √°tomos o enlaces
pueden crearse o desaparecer seg√∫n la simulaci√≥n.</li>
<li><strong>Editores de texto</strong>: representan cada l√≠nea como un
nodo enlazado.</li>
<li><strong>Sistemas de m√∫sica/juegos</strong>: listas circulares para
reproducci√≥n o turnos c√≠clicos.</li>
</ul>
<p><strong>Curiosidad</strong>: Unix implementaba en algunos shells
listas circulares para gestionar el historial de comandos, haciendo que
se ‚Äúreciclaran‚Äù autom√°ticamente.</p>
<hr />
<h2 id="conclusiones">6. Conclusiones</h2>
<p>Las listas enlazadas <strong>resuelven las limitaciones de tama√±o
fijo</strong> de los arrays.</p>
<ul>
<li>Son flexibles: crecen y decrecen din√°micamente.</li>
<li>Permiten inserciones y eliminaciones sin desplazar elementos.</li>
<li>Existen variantes (doble, circular) que se adaptan a diferentes
necesidades.</li>
</ul>
<p>üëâ Filos√≥ficamente, podr√≠amos decir que los arrays representan la
<strong>estabilidad</strong> (todo en su sitio, contiguo, fijo),
mientras que las listas enlazadas representan la
<strong>adaptaci√≥n</strong> (cambian sobre la marcha, sacrificando
eficiencia en el acceso).</p>
<hr />
<h2 id="ejercicios-de-autoevaluaci√≥n">7. Ejercicios de
autoevaluaci√≥n</h2>
<ol type="1">
<li>¬øCu√°l es el coste temporal de acceder al elemento <span
class="math inline">\(i\)</span> en una lista enlazada simple?</li>
<li>Explica por qu√© una lista doblemente enlazada facilita la
eliminaci√≥n de un nodo conocido.</li>
<li>Implementa en pseudoc√≥digo la inserci√≥n al final de una lista
enlazada simple. ¬øCu√°l es su complejidad?</li>
<li>Dise√±a un ejemplo donde una lista circular sea m√°s eficiente que un
array.</li>
<li>¬øPor qu√© las listas enlazadas tienen peor aprovechamiento de la
cach√© que los arrays?</li>
<li>Analiza qu√© estructura usar√≠as para un sistema que procesa
continuamente colas de trabajos.</li>
<li>(Avanzado) ¬øPodr√≠as implementar una lista enlazada en un lenguaje
sin punteros expl√≠citos (ej. Python)? ¬øC√≥mo?</li>
</ol>
<hr />
<h2 id="referencias">Referencias</h2>
<ul>
<li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C.
<em>Introduction to Algorithms</em>. MIT Press.</li>
<li>Goodrich, M. T., Tamassia, R., &amp; Goldwasser, M. H. <em>Data
Structures and Algorithms in Python</em>. Wiley.</li>
<li>Weiss, M. A. <em>Data Structures and Algorithm Analysis</em>.
Pearson.</li>
<li>Sedgewick, R. &amp; Wayne, K. <em>Algorithms</em>.
Addison-Wesley.</li>
<li>Knuth, D. <em>The Art of Computer Programming, Vol. 1: Fundamental
Algorithms</em>. Addison-Wesley.</li>
</ul>
<hr />
</body>
</html>
