<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Curso de Introducci√≥n a Estructuras de Datos y Algoritmos" />
  <title>M√≥dulo 2 ‚Äì Listas enlazadas</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">M√≥dulo 2 ‚Äì Listas enlazadas</h1>
<p class="author">Curso de Introducci√≥n a Estructuras de Datos y Algoritmos</p>
<p class="date">21 de agosto de 2025</p>
</header>
<nav id="TOC" role="doc-toc">

</nav>
<h1 id="m√≥dulo-2-listas-enlazadas">M√≥dulo 2 ‚Äì Listas enlazadas</h1>
<hr />
<h2 id="introducci√≥n">Introducci√≥n</h2>
<p>En el m√≥dulo anterior vimos que los <strong>vectores (arrays)</strong> son estructuras de datos muy √∫tiles cuando queremos <strong>acceder r√°pidamente a un elemento cualquiera</strong> mediante su √≠ndice. Esta eficiencia, sin embargo, viene con un precio: su tama√±o es <strong>fijo</strong>. Si declaramos un vector de tama√±o 10, ni podemos ampliarlo m√°gicamente a 100, ni reducirlo a 5 sin crear otro en memoria.</p>
<p>üìå <strong>Problema motivador</strong>: imagina que gestionas un programa de edici√≥n gen√©tica en el que las bases de ADN se van insertando o eliminando de forma din√°mica. Con arrays, cada modificaci√≥n implica desplazar miles de posiciones en memoria. Con listas enlazadas, basta con ajustar un par de punteros.</p>
<p>Para superar las limitaciones de los vectores aparecen las <strong>listas enlazadas</strong>. Una lista enlazada es una estructura din√°mica en la que cada elemento (o <strong>nodo</strong>) contiene:</p>
<ul>
<li>La informaci√≥n (dato).</li>
<li>Una referencia (puntero o enlace) hacia el siguiente nodo.</li>
</ul>
<p>De esta manera, el tama√±o de la lista se <strong>adapta en tiempo de ejecuci√≥n</strong>: podemos a√±adir y quitar nodos sin necesidad de reservar o liberar grandes bloques contiguos de memoria.</p>
<hr />
<h2 id="estructura-de-una-lista-enlazada-simple">Estructura de una lista enlazada simple</h2>
<p>Una <strong>lista enlazada simple</strong> est√° formada por nodos conectados uno tras otro. Cada nodo tiene dos campos:</p>
<ol type="1">
<li><strong>Dato</strong>: la informaci√≥n que queremos almacenar (n√∫meros, cadenas, estructuras).</li>
<li><strong>Enlace</strong>: un puntero que indica la direcci√≥n del siguiente nodo.</li>
</ol>
<p>El primer nodo se denomina <strong>cabeza</strong> (<em>head</em>), y el √∫ltimo nodo apunta a <code>null</code>, se√±alando el final de la lista.</p>
<figure>
<img src="../../images/linked_list.png" alt="" /><figcaption>Lista enlazada simple</figcaption>
</figure>
<p><em>Figura 2: lista enlazada simple de cinco nodos.</em></p>
<h3 id="operaciones-b√°sicas-y-coste">Operaciones b√°sicas y coste</h3>
<ul>
<li><strong>Inserci√≥n al inicio</strong> ‚Üí <span class="math inline">\(O(1)\)</span> Basta con redirigir el puntero de la cabeza.</li>
<li><strong>Inserci√≥n al final</strong> ‚Üí <span class="math inline">\(O(n)\)</span> Necesitamos recorrer toda la lista hasta el √∫ltimo nodo.</li>
<li><strong>Inserci√≥n intermedia</strong> ‚Üí <span class="math inline">\(O(n)\)</span> Hay que llegar a la posici√≥n deseada.</li>
<li><strong>Eliminaci√≥n</strong> ‚Üí <span class="math inline">\(O(1)\)</span> si es la cabeza; <span class="math inline">\(O(n)\)</span> si est√° en medio (hay que conocer el nodo anterior).</li>
<li><strong>B√∫squeda</strong> ‚Üí <span class="math inline">\(O(n)\)</span>, porque no existe acceso aleatorio.</li>
</ul>
<h4 id="pseudoc√≥digo-de-inserci√≥n-al-inicio">Pseudoc√≥digo de inserci√≥n al inicio</h4>
<pre class="text"><code>NODO insertarInicio(LISTA L, DATO x):
    nuevo ‚Üê crearNodo(x)
    nuevo.siguiente ‚Üê L.cabeza
    L.cabeza ‚Üê nuevo</code></pre>
<h4 id="pseudoc√≥digo-de-b√∫squeda">Pseudoc√≥digo de b√∫squeda</h4>
<pre class="text"><code>NODO buscar(LISTA L, DATO x):
    actual ‚Üê L.cabeza
    mientras actual ‚â† null hacer
        si actual.dato = x entonces
            devolver actual
        actual ‚Üê actual.siguiente
    devolver null</code></pre>
<p>La lista enlazada simple nos recuerda que <strong>a veces el camino importa m√°s que la meta</strong>. Para llegar al nodo 5, no podemos saltar, debemos recorrer la lista paso a paso, como quien lee una novela p√°gina a p√°gina.</p>
<hr />
<h2 id="listas-doblemente-enlazadas">Listas doblemente enlazadas</h2>
<p>Una mejora importante es la <strong>lista doblemente enlazada</strong>. Aqu√≠ cada nodo guarda tres campos:</p>
<ul>
<li>El <strong>dato</strong>.</li>
<li>Un <strong>puntero al siguiente</strong>.</li>
<li>Un <strong>puntero al anterior</strong>.</li>
</ul>
<p>Esto permite recorrer la lista en <strong>ambos sentidos</strong> y facilita operaciones como eliminar un nodo sin necesidad de conocer a su predecesor.</p>
<figure>
<img src="../../images/doubly_linked_list.png" alt="" /><figcaption>Lista doblemente enlazada</figcaption>
</figure>
<p><em>Figura 3: lista doblemente enlazada.</em></p>
<p>‚ö° Inconveniente: se necesita m√°s memoria por nodo y m√°s trabajo al insertar (hay que actualizar dos punteros en vez de uno).</p>
<p>üìú <strong>An√©cdota hist√≥rica</strong>: las primeras implementaciones de editores de texto en los a√±os 70 (como <em>EMACS</em>) usaban listas doblemente enlazadas para representar l√≠neas de texto, porque resultaba natural moverse hacia adelante y atr√°s en el documento.</p>
<hr />
<h2 id="listas-circulares">Listas circulares</h2>
<p>En una <strong>lista circular</strong>, el √∫ltimo nodo no apunta a <code>null</code> sino de nuevo al primero. De esta forma, el recorrido nunca se detiene: no existe un ‚Äúfinal‚Äù.</p>
<p>Caracter√≠sticas:</p>
<ul>
<li>La <strong>cabeza</strong> puede ser cualquier nodo.</li>
<li>Mantener un puntero al √∫ltimo nodo permite insertar al inicio y al final en tiempo constante.</li>
</ul>
<figure>
<img src="../../images/circular_linked_list.png" alt="" /><figcaption>Lista circular</figcaption>
</figure>
<p><em>Figura 4: lista enlazada circular.</em></p>
<h3 id="aplicaciones-t√≠picas">Aplicaciones t√≠picas</h3>
<ul>
<li><strong>Planificadores de CPU</strong> (algoritmo round-robin).</li>
<li><strong>Listas de reproducci√≥n de m√∫sica</strong> que vuelven al inicio.</li>
<li><strong>Juegos de mesa</strong> donde los turnos son c√≠clicos.</li>
</ul>
<p>Tambi√©n existen <strong>listas doblemente circulares</strong>, que permiten navegar hacia adelante y atr√°s sin l√≠mites.</p>
<hr />
<h2 id="comparaci√≥n-con-arrays">Comparaci√≥n con arrays</h2>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 47%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Caracter√≠stica</th>
<th>Lista enlazada</th>
<th>Vector (array)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Crecimiento</strong></td>
<td>Din√°mico, tama√±o ajustable en tiempo de ejecuci√≥n.</td>
<td>Est√°tico, tama√±o fijo.</td>
</tr>
<tr class="even">
<td><strong>Acceso aleatorio</strong></td>
<td>No, recorrido secuencial <span class="math inline">\(O(n)\)</span>.</td>
<td>S√≠, acceso <span class="math inline">\(O(1)\)</span> mediante √≠ndices.</td>
</tr>
<tr class="odd">
<td><strong>Inserci√≥n/eliminaci√≥n</strong></td>
<td><span class="math inline">\(O(1)\)</span> si se conoce el nodo; <span class="math inline">\(O(n)\)</span> si hay que recorrer.</td>
<td><span class="math inline">\(O(n)\)</span> (desplazamiento de elementos).</td>
</tr>
<tr class="even">
<td><strong>Uso de memoria</strong></td>
<td>Requiere punteros adicionales.</td>
<td>M√°s compacta y contigua.</td>
</tr>
<tr class="odd">
<td><strong>Localidad de referencia</strong></td>
<td>Baja: nodos dispersos en memoria.</td>
<td>Alta: aprovecha mejor la cach√©.</td>
</tr>
</tbody>
</table>
<p><strong>Conclusi√≥n pr√°ctica</strong>:</p>
<ul>
<li>Usa <strong>listas enlazadas</strong> si habr√° muchas inserciones y eliminaciones.</li>
<li>Usa <strong>arrays</strong> si necesitas acceso r√°pido por √≠ndice y mejor rendimiento en cach√©.</li>
</ul>
<p>üìå Filosof√≠a: la elecci√≥n de la estructura de datos depende del <strong>patr√≥n de uso</strong>, no de una ‚Äúmejor‚Äù universal.</p>
<hr />
<h2 id="casos-de-uso-en-bioinform√°tica-y-computaci√≥n">Casos de uso en bioinform√°tica y computaci√≥n</h2>
<ul>
<li><strong>Gesti√≥n din√°mica de secuencias</strong>: en ediciones de ADN, cuando se insertan o eliminan bases constantemente.</li>
<li><strong>Colas de procesos</strong>: en sistemas operativos, donde los procesos entran y salen de forma continua.</li>
<li><strong>Modelado molecular din√°mico</strong>: los √°tomos o enlaces pueden crearse o desaparecer seg√∫n la simulaci√≥n.</li>
<li><strong>Editores de texto</strong>: representan cada l√≠nea como un nodo enlazado.</li>
<li><strong>Sistemas de m√∫sica/juegos</strong>: listas circulares para reproducci√≥n o turnos c√≠clicos.</li>
</ul>
<p><strong>Curiosidad</strong>: Unix implementaba en algunos shells listas circulares para gestionar el historial de comandos, haciendo que se ‚Äúreciclaran‚Äù autom√°ticamente.</p>
<hr />
<h2 id="conclusiones">Conclusiones</h2>
<p>Las listas enlazadas <strong>resuelven las limitaciones de tama√±o fijo</strong> de los arrays.</p>
<ul>
<li>Son flexibles: crecen y decrecen din√°micamente.</li>
<li>Permiten inserciones y eliminaciones sin desplazar elementos.</li>
<li>Existen variantes (doble, circular) que se adaptan a diferentes necesidades.</li>
</ul>
<p>üëâ Filos√≥ficamente, podr√≠amos decir que los arrays representan la <strong>estabilidad</strong> (todo en su sitio, contiguo, fijo), mientras que las listas enlazadas representan la <strong>adaptaci√≥n</strong> (cambian sobre la marcha, sacrificando eficiencia en el acceso).</p>
<hr />
<h2 id="ejercicios-de-autoevaluaci√≥n">Ejercicios de autoevaluaci√≥n</h2>
<ol type="1">
<li>¬øCu√°l es el coste temporal de acceder al elemento <span class="math inline">\(i\)</span> en una lista enlazada simple?</li>
<li>Explica por qu√© una lista doblemente enlazada facilita la eliminaci√≥n de un nodo conocido.</li>
<li>Implementa en pseudoc√≥digo la inserci√≥n al final de una lista enlazada simple. ¬øCu√°l es su complejidad?</li>
<li>Dise√±a un ejemplo donde una lista circular sea m√°s eficiente que un array.</li>
<li>¬øPor qu√© las listas enlazadas tienen peor aprovechamiento de la cach√© que los arrays?</li>
<li>Analiza qu√© estructura usar√≠as para un sistema que procesa continuamente colas de trabajos.</li>
<li>(Avanzado) ¬øPodr√≠as implementar una lista enlazada en un lenguaje sin punteros expl√≠citos (ej. Python)? ¬øC√≥mo?</li>
</ol>
<hr />
<h2 id="referencias">Referencias</h2>
<ul>
<li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. <em>Introduction to Algorithms</em>. MIT Press.</li>
<li>Goodrich, M. T., Tamassia, R., &amp; Goldwasser, M. H. <em>Data Structures and Algorithms in Python</em>. Wiley.</li>
<li>Weiss, M. A. <em>Data Structures and Algorithm Analysis</em>. Pearson.</li>
<li>Sedgewick, R. &amp; Wayne, K. <em>Algorithms</em>. Addison-Wesley.</li>
<li>Knuth, D. <em>The Art of Computer Programming, Vol. 1: Fundamental Algorithms</em>. Addison-Wesley.</li>
</ul>
<hr />
</body>
</html>
