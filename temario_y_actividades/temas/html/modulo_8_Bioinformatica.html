<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Curso de Introducci√≥n a Estructuras de Datos y Algoritmos" />
  <title>M√≥dulo 8 ‚Äì Algoritmos y estructuras de datos en bioinform√°tica</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="/usr/share/javascript/mathjax/MathJax.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">M√≥dulo 8 ‚Äì Algoritmos y estructuras de datos en
bioinform√°tica</h1>
<p class="author">Curso de Introducci√≥n a Estructuras de Datos y
Algoritmos</p>
<p class="date">4 de septiembre de 2025</p>
</header>
<nav id="TOC" role="doc-toc">

</nav>
<h1
id="m√≥dulo-8-algoritmos-y-estructuras-de-datos-el-coraz√≥n-computacional-de-la-bioinform√°tica">M√≥dulo
8 ‚Äì Algoritmos y Estructuras de Datos: El Coraz√≥n Computacional de la
Bioinform√°tica</h1>
<h2 id="motivaci√≥n-de-la-biolog√≠a-a-los-terabytes">Motivaci√≥n: De la
Biolog√≠a a los Terabytes üß¨üíª</h2>
<p>La biolog√≠a del siglo XXI ha experimentado una transformaci√≥n
radical. Hemos pasado de estudiar organismos uno a uno a secuenciar
genomas completos en cuesti√≥n de horas. Esta revoluci√≥n ha generado un
<strong>diluvio de datos</strong> de una escala sin precedentes. El
genoma humano, por ejemplo, es una secuencia de 3.200 millones de
caracteres. Un solo experimento de expresi√≥n g√©nica puede generar una
matriz con cientos de miles de puntos de datos.</p>
<p><strong>La Filosof√≠a Central</strong>: En este nuevo paradigma, los
datos biol√≥gicos son demasiado vastos para la intuici√≥n humana. Un
bi√≥logo no puede ‚Äúleer‚Äù un genoma para encontrar un gen, de la misma
manera que un bibliotecario no puede leer todos los libros de una
biblioteca para encontrar una frase. La <strong>bioinform√°tica</strong>
nace de esta necesidad: es la disciplina que desarrolla los m√©todos
computacionales para almacenar, organizar, analizar e interpretar esta
inmensa cantidad de informaci√≥n.</p>
<p>Este m√≥dulo es la culminaci√≥n de todo el curso. Aqu√≠ veremos c√≥mo los
conceptos que hemos estudiado ‚Äîdesde la humilde b√∫squeda lineal hasta
los complejos recorridos de grafos‚Äî no son meros ejercicios te√≥ricos,
sino las <strong>herramientas indispensables</strong> que permiten hacer
descubrimientos cient√≠ficos. Sin algoritmos eficientes, la gen√≥mica
moderna, la medicina personalizada y el dise√±o de f√°rmacos ser√≠an,
sencillamente, imposibles.</p>
<hr />
<h2
id="procesamiento-de-secuencias-biol√≥gicas-el-lenguaje-de-la-vida">Procesamiento
de Secuencias Biol√≥gicas: El Lenguaje de la Vida</h2>
<p>La tarea m√°s fundamental en bioinform√°tica es el an√°lisis de
secuencias de ADN, ARN y prote√≠nas. La eficiencia aqu√≠ no es un lujo, es
una necesidad.</p>
<h3 id="b√∫squeda-de-patrones-motivos">B√∫squeda de Patrones
(Motivos)</h3>
<ul>
<li><strong>Problema Real</strong>: No se trata solo de encontrar una
subsecuencia. Buscamos ‚Äúse√±ales‚Äù con significado biol√≥gico.
<ul>
<li><strong>Ejemplo 1</strong>: Localizar todas las ocurrencias del
cod√≥n de inicio <code>ATG</code> para predecir d√≥nde comienzan los
genes.</li>
<li><strong>Ejemplo 2</strong>: Encontrar secuencias cortas y
espec√≠ficas (ej. <code>TATAAT</code>, la ‚Äúcaja TATA‚Äù) donde las
prote√≠nas reguladoras se unen al ADN para iniciar la transcripci√≥n.</li>
<li><strong>Ejemplo 3</strong>: Identificar repeticiones de
microsat√©lites (ej. <code>CAGCAGCAG...</code>), cuya expansi√≥n est√°
asociada a enfermedades como la de Huntington.</li>
</ul></li>
<li><strong>Estrategias y Estructuras</strong>:
<ul>
<li><strong>Tablas Hash de <em>k-mers</em></strong>:
<ul>
<li><strong>Idea</strong>: En lugar de escanear el genoma de 3.000
millones de bases cada vez que buscamos un patr√≥n, lo pre-procesamos una
sola vez. Se desliza una ventana de tama√±o fijo <em>k</em> (ej. k=25) a
lo largo de todo el genoma y se almacena cada <em>k-mer</em> y su(s)
posici√≥n(es) en una tabla hash.</li>
<li><strong>Caso Pr√°ctico</strong>: Para encontrar d√≥nde se une una
prote√≠na que reconoce la secuencia <code>GATTACA</code>, en lugar de un
escaneo de <span class="math inline">\(O(n)\)</span>, simplemente
calculamos el hash de <code>GATTACA</code> y consultamos la tabla en
tiempo <strong><span class="math inline">\(O(1)\)</span></strong> para
obtener una lista de todas sus localizaciones. ¬°La diferencia entre
horas de c√≥mputo y una fracci√≥n de segundo!</li>
</ul></li>
<li><strong>√Årboles de Sufijos y Tries</strong>:
<ul>
<li><strong>Filosof√≠a</strong>: Son la soluci√≥n ‚Äúdefinitiva‚Äù para la
b√∫squeda de patrones. Un √°rbol de sufijos es una estructura de datos que
contiene <strong>todos los sufijos</strong> de una cadena de una manera
comprimida.</li>
<li><strong>Analog√≠a</strong>: Imagina tener un √≠ndice de un libro que
no solo te dice en qu√© p√°gina aparece cada palabra, sino tambi√©n cada
frase, cada p√°rrafo y cada combinaci√≥n de letras posible. Eso es un
√°rbol de sufijos para una secuencia. Permite responder preguntas
complejas como ‚Äú¬øcu√°l es la subsecuencia m√°s larga que se repite en este
genoma?‚Äù en tiempo proporcional a la longitud del patr√≥n, no del
genoma.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="comparaci√≥n-de-secuencias-alineamiento">Comparaci√≥n de
Secuencias (Alineamiento)</h3>
<ul>
<li><p><strong>Problema Real</strong>: ¬øC√≥mo cuantificamos la similitud
entre dos genes? Esto es crucial para inferir funciones (si un gen
desconocido es 80% similar a un gen conocido, probablemente tengan
funciones parecidas) o para trazar relaciones evolutivas.</p></li>
<li><p><strong>Algoritmos basados en Programaci√≥n Din√°mica</strong>:</p>
<ul>
<li><strong>La Idea</strong>: El alineamiento se visualiza como
encontrar el ‚Äúmejor camino‚Äù a trav√©s de una matriz donde un eje es la
secuencia A y el otro la secuencia B. Cada celda <span
class="math inline">\((i, j)\)</span> de la matriz almacena la
puntuaci√≥n del mejor alineamiento posible entre el prefijo <span
class="math inline">\(A[1..i]\)</span> y <span
class="math inline">\(B[1..j]\)</span>.</li>
<li><strong>Analog√≠a</strong>: Es como un juego de mesa donde puedes
moverte en diagonal (match/mismatch), hacia abajo (gap en A) o a la
derecha (gap en B). Cada movimiento tiene una puntuaci√≥n. La
programaci√≥n din√°mica garantiza que, para calcular la puntuaci√≥n de una
celda, ya hemos calculado las puntuaciones √≥ptimas de las celdas de las
que depende, evitando volver a calcular nada.</li>
<li><strong>Needleman-Wunsch vs.¬†Smith-Waterman</strong>: El primero
encuentra el mejor alineamiento <strong>global</strong> (de principio a
fin), ideal para comparar dos genes que se cree que est√°n relacionados
en toda su longitud. El segundo encuentra la mejor regi√≥n de similitud
<strong>local</strong>, perfecto para descubrir dominios funcionales
compartidos dentro de prote√≠nas m√°s grandes.</li>
</ul></li>
<li><p><strong>Heur√≠sticas como BLAST</strong>:</p>
<ul>
<li><strong>Motivaci√≥n</strong>: Un alineamiento con programaci√≥n
din√°mica entre dos genomas es computacionalmente inviable. BLAST
(<em>Basic Local Alignment Search Tool</em>) es una heur√≠stica ingeniosa
que cambia la pregunta de ‚Äú¬øcu√°l es el mejor alineamiento?‚Äù a ‚Äú¬øexisten
regiones de alta similitud?‚Äù.</li>
<li><strong>Funcionamiento</strong>: BLAST utiliza <strong>hashing de
k-mers</strong> para encontrar ‚Äúsemillas‚Äù (matches exactos muy cortos)
entre las dos secuencias. Luego, intenta extender estas semillas en
ambas direcciones para construir un alineamiento local m√°s largo y
significativo. Es un compromiso brillante: sacrifica la garant√≠a de
optimalidad por una velocidad miles de veces mayor.</li>
</ul></li>
</ul>
<hr />
<h2 id="ordenaci√≥n-poniendo-en-fila-los-datos-biol√≥gicos">Ordenaci√≥n:
Poniendo en Fila los Datos Biol√≥gicos</h2>
<p>La ordenaci√≥n es un paso de pre-procesamiento omnipresente. *
<strong>Caso Pr√°ctico 1: An√°lisis de datos de secuenciaci√≥n
(NGS)</strong>. Un experimento produce cientos de millones de lecturas
de ADN cortas (<em>reads</em>). Antes de mapearlas contra un genoma de
referencia, es √∫til ordenarlas. ¬øPor qu√©? Un lote de lecturas ordenadas
lexicogr√°ficamente puede ser procesado de forma m√°s eficiente por los
algoritmos de mapeo debido a una mejor localidad de cach√© y patrones de
acceso a memoria. * <strong>Caso Pr√°ctico 2: An√°lisis de expresi√≥n
g√©nica</strong>. Se tiene una matriz donde las filas son genes y las
columnas son pacientes. Ordenar los genes por su nivel de expresi√≥n
promedio permite identificar r√°pidamente los genes m√°s y menos activos
en una condici√≥n particular (ej. un tipo de c√°ncer).</p>
<ul>
<li><strong>Algoritmos aplicados</strong>:
<ul>
<li><strong>Merge Sort Externo</strong>: Cuando el archivo de lecturas
de NGS ocupa 100 GB y solo tienes 16 GB de RAM, es imposible cargarlo
todo en memoria. Merge Sort es el algoritmo natural aqu√≠: lee un trozo
del archivo que quepa en memoria, lo ordena con Quicksort, lo escribe en
un archivo temporal. Repite esto hasta procesar todo el archivo.
Finalmente, fusiona todos los archivos temporales ordenados en un √∫nico
archivo final ordenado.</li>
<li><strong>Radix Sort</strong>: Para ordenar secuencias de ADN, Radix
Sort puede ser mucho m√°s r√°pido que Quicksort. ¬øPor qu√©? Porque el
‚Äúalfabeto‚Äù es muy peque√±o ({A, C, G, T}). Radix Sort ordena las
secuencias bas√°ndose en el √∫ltimo car√°cter, luego el pen√∫ltimo, y as√≠
sucesivamente. Su complejidad <span class="math inline">\(O(d \cdot
n)\)</span> (donde d es la longitud de la secuencia) supera a <span
class="math inline">\(O(n \log n)\)</span> en este contexto
espec√≠fico.</li>
</ul></li>
</ul>
<hr />
<h2 id="grafos-la-estructura-de-las-redes-biol√≥gicas">Grafos: La
Estructura de las Redes Biol√≥gicas</h2>
<p>La biolog√≠a est√° llena de redes, y los grafos son el lenguaje natural
para describirlas.</p>
<ul>
<li><strong>Redes de Interacci√≥n Prote√≠na-Prote√≠na (PPI)</strong>:
<ul>
<li><strong>Modelo</strong>: Los nodos son prote√≠nas, las aristas
indican que dos prote√≠nas interact√∫an f√≠sicamente.</li>
<li><strong>An√°lisis</strong>: Se pueden aplicar algoritmos de grafos
para encontrar ‚Äúm√≥dulos‚Äù o cl√∫steres de prote√≠nas densamente conectadas,
que a menudo corresponden a complejos moleculares con una funci√≥n
biol√≥gica com√∫n. Un <strong>DFS</strong> puede encontrar todos los
miembros de una ruta de se√±alizaci√≥n.</li>
<li><strong>Caso Pr√°ctico</strong>: Descubrir que una prote√≠na asociada
a una enfermedad es un ‚Äúhub‚Äù (un nodo con muchas conexiones) en la red
puede identificarla como una diana terap√©utica prometedora.</li>
</ul></li>
<li><strong>Grafos de Ensamblado de Genomas</strong>:
<ul>
<li><strong>El Problema</strong>: Reconstruir un libro de 3.000 millones
de letras a partir de millones de fragmentos de 150 letras que se
solapan.</li>
<li><strong>La Soluci√≥n (Grafos de Bruijn)</strong>: En lugar de tratar
cada fragmento como un nodo (lo que ser√≠a muy complejo), los nodos son
todos los <em>k-mers</em> (ej. subsecuencias de 30 letras) presentes en
los fragmentos. Se dibuja una arista dirigida desde el k-mer A al k-mer
B si se solapan en k-1 letras.</li>
<li><strong>La Magia</strong>: El problema biol√≥gico de ‚Äúreconstruir la
secuencia‚Äù se transforma en el problema cl√°sico de la teor√≠a de grafos
de ‚Äúencontrar un camino Euleriano‚Äù (un camino que visita cada arista
exactamente una vez). ¬°Un problema aparentemente intratable se convierte
en uno bien estudiado!</li>
</ul></li>
</ul>
<hr />
<h2 id="√°rboles-jerarqu√≠as-en-evoluci√≥n-y-datos">√Årboles: Jerarqu√≠as en
Evoluci√≥n y Datos</h2>
<ul>
<li><strong>√Årboles Filogen√©ticos</strong>:
<ul>
<li><strong>Modelo</strong>: Representan la historia evolutiva. Las
hojas son las especies actuales y los nodos internos son los ancestros
comunes. La longitud de las ramas puede representar el tiempo evolutivo
o la cantidad de cambio gen√©tico.</li>
<li><strong>Construcci√≥n</strong>: Se parte de una matriz de distancias
(ej. calculada alineando un gen entre todas las especies). Algoritmos
como <strong>UPGMA</strong> (un m√©todo de clustering jer√°rquico) agrupan
iterativamente las dos especies m√°s cercanas, creando un nuevo nodo
ancestro, hasta que se forma el √°rbol completo.</li>
</ul></li>
<li><strong>BST y sus variantes en Bases de Datos</strong>:
<ul>
<li><strong>Caso Pr√°ctico</strong>: Bases de datos como Ensembl o
GenBank almacenan informaci√≥n sobre millones de genes. Cuando un
investigador busca ‚Äúel gen BRCA1 en humanos‚Äù, el sistema no puede
permitirse una b√∫squeda lineal. Internamente, utiliza estructuras de
datos avanzadas como los <strong>√Årboles B+</strong> (una variante de
BST optimizada para disco) para indexar los datos por nombre de gen,
especie, posici√≥n cromos√≥mica, etc., permitiendo recuperaciones casi
instant√°neas.</li>
</ul></li>
</ul>
<hr />
<h2
id="conclusiones-finales-la-caja-de-herramientas-del-bioinform√°tico">Conclusiones
Finales: La Caja de Herramientas del Bioinform√°tico</h2>
<p>Este m√≥dulo demuestra que la bioinform√°tica no es simplemente
‚Äúaplicar programas a datos biol√≥gicos‚Äù. Es el campo donde la teor√≠a de
la computaci√≥n se encuentra con los desaf√≠os m√°s fundamentales de la
biolog√≠a.</p>
<ul>
<li><strong>La Eficiencia es Descubrimiento</strong>: La diferencia
entre un algoritmo <span class="math inline">\(O(n^2)\)</span> y uno
<span class="math inline">\(O(n \log n)\)</span> puede ser la diferencia
entre un an√°lisis que tarda un siglo y uno que tarda un d√≠a. Un
algoritmo m√°s r√°pido puede permitir explorar hip√≥tesis que antes eran
inabordables.</li>
<li><strong>La Abstracci√≥n es Poder</strong>: La capacidad de ver un
problema de ensamblado de genomas como un camino en un grafo, o un
problema de b√∫squeda de patrones como una consulta a una tabla hash, es
la habilidad central de un bioinform√°tico.</li>
<li><strong>No hay ‚ÄúBala de Plata‚Äù</strong>: No existe un √∫nico
algoritmo o estructura de datos que resuelva todo. La elecci√≥n correcta
depende cr√≠ticamente de la escala de los datos, la pregunta biol√≥gica y
las limitaciones de hardware. Un buen bioinform√°tico conoce su caja de
herramientas y sabe cu√°ndo usar un martillo (Quicksort), un
destornillador (BFS) o una llave inglesa de precisi√≥n (un √°rbol de
sufijos).</li>
</ul>
<hr />
<h2 id="ejercicios-de-autoevaluaci√≥n">Ejercicios de autoevaluaci√≥n</h2>
<ol type="1">
<li>Dise√±a un pseudoc√≥digo para buscar un motivo de longitud 3 en una
secuencia de ADN usando <strong>tablas hash de k-mers</strong> (ap√≥yate
en el M√≥dulo 6).<br />
</li>
<li>¬øQu√© ventajas tiene <strong>radix sort</strong> sobre quicksort para
ordenar secuencias de nucle√≥tidos? (revisa M√≥dulo 7).<br />
</li>
<li>Explica c√≥mo un <strong>grafo de Bruijn</strong> ayuda en el
ensamblado de genomas (conecta con M√≥dulo 5).<br />
</li>
<li>Construye un peque√±o <strong>√°rbol filogen√©tico</strong> a partir de
tres secuencias ficticias.<br />
</li>
<li>El alineamiento de dos secuencias de 1 mill√≥n de bases con
Needleman‚ÄìWunsch es inviable (<span
class="math inline">\(O(n^2)\)</span>). ¬øQu√© estrategias alternativas
existen?</li>
</ol>
<hr />
<h2 id="referencias">Referencias</h2>
<ul>
<li>Jones, N. C., &amp; Pevzner, P. A. <em>An Introduction to
Bioinformatics Algorithms</em>. MIT Press.<br />
</li>
<li>Durbin, R., Eddy, S., Krogh, A., &amp; Mitchison, G. <em>Biological
Sequence Analysis</em>. Cambridge University Press.<br />
</li>
<li>Compeau, P., &amp; Pevzner, P. <em>Bioinformatics Algorithms: An
Active Learning Approach</em>. Active Learning Publishers.</li>
</ul>
<hr />
</body>
</html>
